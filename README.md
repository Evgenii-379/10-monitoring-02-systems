# **Домашнее задание к занятию "13.Системы мониторинга"** - ***Вуколов Евгений***
 
## ***Обязательные задания***
 
1. Вас пригласили настроить мониторинг на проект. На онбординге вам рассказали, что проект представляет из себя
платформу для вычислений с выдачей текстовых отчетов, которые сохраняются на диск. Взаимодействие с платформой
осуществляется по протоколу http. Также вам отметили, что вычисления загружают ЦПУ. Какой минимальный набор метрик вы
выведите в мониторинг и почему?
#
2. Менеджер продукта посмотрев на ваши метрики сказал, что ему непонятно что такое RAM/inodes/CPUla. Также он сказал,
что хочет понимать, насколько мы выполняем свои обязанности перед клиентами и какое качество обслуживания. Что вы
можете ему предложить?
#
3. Вашей DevOps команде в этом году не выделили финансирование на построение системы сбора логов. Разработчики в свою
очередь хотят видеть все ошибки, которые выдают их приложения. Какое решение вы можете предпринять в этой ситуации,
чтобы разработчики получали ошибки приложения?
#
4. Вы, как опытный SRE, сделали мониторинг, куда вывели отображения выполнения SLA=99% по http кодам ответов.
Вычисляете этот параметр по следующей формуле: summ_2xx_requests/summ_all_requests. Данный параметр не поднимается выше
70%, но при этом в вашей системе нет кодов ответа 5xx и 4xx. Где у вас ошибка?
#
5. Опишите основные плюсы и минусы pull и push систем мониторинга.
#
6. Какие из ниже перечисленных систем относятся к push модели, а какие к pull? А может есть гибридные?
 
    - Prometheus
    - TICK
    - Zabbix
    - VictoriaMetrics
    - Nagios
#
7. Склонируйте себе [репозиторий](https://github.com/influxdata/sandbox/tree/master) и запустите TICK-стэк,
используя технологии docker и docker-compose.
 
В виде решения на это упражнение приведите скриншот веб-интерфейса ПО chronograf (`http://localhost:8888`).
 
P.S.: если при запуске некоторые контейнеры будут падать с ошибкой - проставьте им режим `Z`, например
`./data:/var/lib:Z`
#
8. Перейдите в веб-интерфейс Chronograf (http://localhost:8888) и откройте вкладку Data explorer.
        
    - Нажмите на кнопку Add a query
    - Изучите вывод интерфейса и выберите БД telegraf.autogen
    - В `measurments` выберите cpu->host->telegraf-getting-started, а в `fields` выберите usage_system. Внизу появится график утилизации cpu.
    - Вверху вы можете увидеть запрос, аналогичный SQL-синтаксису. Поэкспериментируйте с запросом, попробуйте изменить группировку и интервал наблюдений.
 
Для выполнения задания приведите скриншот с отображением метрик утилизации cpu из веб-интерфейса.
#
9. Изучите список [telegraf inputs](https://github.com/influxdata/telegraf/tree/master/plugins/inputs).
Добавьте в конфигурацию telegraf следующий плагин - [docker](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/docker):
```
[[inputs.docker]]
  endpoint = "unix:///var/run/docker.sock"
```
 
Дополнительно вам может потребоваться донастройка контейнера telegraf в `docker-compose.yml` дополнительного volume и
режима privileged:
```
  telegraf:
    image: telegraf:1.4.0
    privileged: true
    volumes:
      - ./etc/telegraf.conf:/etc/telegraf/telegraf.conf:Z
      - /var/run/docker.sock:/var/run/docker.sock:Z
    links:
      - influxdb
    ports:
      - "8092:8092/udp"
      - "8094:8094"
      - "8125:8125/udp"
```
 
После настройке перезапустите telegraf, обновите веб интерфейс и приведите скриншотом список `measurments` в
веб-интерфейсе базы telegraf.autogen . Там должны появиться метрики, связанные с docker.
 
Факультативно можете изучить какие метрики собирает telegraf после выполнения данного задания.
 
## **Дополнительное задание (со звездочкой*)** - необязательно к выполнению
 
1. Вы устроились на работу в стартап. На данный момент у вас нет возможности развернуть полноценную систему
мониторинга, и вы решили самостоятельно написать простой python3-скрипт для сбора основных метрик сервера. Вы, как
опытный системный-администратор, знаете, что системная информация сервера лежит в директории `/proc`.
Также, вы знаете, что в системе Linux есть  планировщик задач cron, который может запускать задачи по расписанию.
 
Суммировав все, вы спроектировали приложение, которое:
- является python3 скриптом
- собирает метрики из папки `/proc`
- складывает метрики в файл 'YY-MM-DD-awesome-monitoring.log' в директорию /var/log
(YY - год, MM - месяц, DD - день)
- каждый сбор метрик складывается в виде json-строки, в виде:
  + timestamp (временная метка, int, unixtimestamp)
  + metric_1 (метрика 1)
  + metric_2 (метрика 2)
 
     ...
     
  + metric_N (метрика N)
 
- сбор метрик происходит каждую 1 минуту по cron-расписанию
 
Для успешного выполнения задания нужно привести:
 
а) работающий код python3-скрипта,
 
б) конфигурацию cron-расписания,
 
в) пример верно сформированного 'YY-MM-DD-awesome-monitoring.log', имеющий не менее 5 записей,
 
P.S.: количество собираемых метрик должно быть не менее 4-х.
P.P.S.: по желанию можно себя не ограничивать только сбором метрик из `/proc`.
 
2. В веб-интерфейсе откройте вкладку `Dashboards`. Попробуйте создать свой dashboard с отображением:
 
    - утилизации ЦПУ
    - количества использованного RAM
    - утилизации пространства на дисках
    - количество поднятых контейнеров
    - аптайм
    - ...
    - фантазируйте)
    
    ---
 
### Как оформить ДЗ?
 
Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

# **Решение**

1.
- Загрузка CPU, так как вычисления нагружают процессор, поэтому нужно отслеживать его использование.Это может предотвратить перегрузки и оптимизировать 
  производительность.
- Использование памяти RAM, контроль потребления оперативной памяти.
- Доступное дисковое пространство, так как текстовые отчёты сохраняются на диск, нужно следить за свободным местом, чтобы избежать остановки работы из-за 
  переполнения.
- HTTP Response Time (время отклика), это позволяет оценить производительность платформы.
- HTTP Error Rate: Процент запросов, завершившихся ошибками.


2. Можно предложить следующий набор метрик:
- Время отклика. Среднее время между получением запроса клиента и первым ответом службы поддержки. Это поможет оценить скорость реакции на обращения клиентов.
- Оценка удовлетворенности клиентов после взаимодействия со службой поддержки.
- Показатель готовности клиентов рекомендовать вашу платформу другим.
- Уровень доступности сервиса. Процент времени, когда платформа доступна и функционирует без сбоев. 
Эти метрики помогут менеджеру продукта лучше понять качество обслуживания клиентов, выполнение обязательств перед ними и общую эффективность платформы.


3. Можно предложить следующее бесплатное решение:
Использовать ELK-стек (Elasticsearch, Logstash, Kibana) в бесплатной версии для построения базовой системы сбора и анализа логов12. 
Этот стек предоставляет все необходимые компоненты для сбора, хранения и визуализации логов, включая ошибки приложений.
Преимущества:
- Бесплатность: ELK-стек доступен в open-source версии без ограничений по функциональности.
- Масштабируемость: можно начать с небольшой конфигурации и расширять по мере необходимости.
- Гибкость: возможность настройки под конкретные нужды разработчиков.
- Широкое сообщество: большое количество документации и поддержки от сообщества.
Так же есть альтернативное решение- это использование бесплатных версий Graylog Open и Grafana Loki.


4. Параметр не поднимается выше 70%, потому что есть ошибка в формуле расчета SLA. В данный формуле учитывается только коды 2xx как успешные и 
не учитываются успешные запросы с кодами 1xx и 3xx, которые также являются частью нормального функционирования системы.

5. Pull системы мониторинга
Плюсы:
- Централизованная настройка: все настройки, таргеты и частоты опроса хранятся в одном месте на центральном сервере.
- Простое обнаружение недоступности: быстро узнаете о проблемах с доступностью узлов.
- Минимальная связность: приложение и сервис метрик связаны минимально.
- Подходят для долгоживущих приложений.

Минусы:
- Сложности с NAT: система мониторинга должна иметь возможность подключиться к приложению.
- Более сложная настройка безопасности: требуется настройка реверс-прокси, файрволла и экспортера.
- Сложное развертывание: необходимо настроить дополнительные компоненты на конечном сервере.

Push системы мониторинга
Плюсы:
- Подходят для короткоживущих приложений1.
- Проще настройка безопасности: достаточно защитить только центральную ноду.
- Легкое развертывание: требуется только прописать хост центральной ноды и данные доступа.
- Эффективное масштабирование: агенты распределены по узлам, что снижает нагрузку на центральную ноду.

Минусы:
- Более сильная связность: приложение должно знать, куда отправлять метрики.
- Сложнее обнаружить причину недоступности узла.
- Необходимость доставки авторизационных ключей и настроек подключения на агенты


6. Pull модель:
- Prometheus
- Nagios

Push модель:
- TICK (Telegraf отправляет метрики в InfluxDB)

Гибридные (поддерживают обе модели):
- VictoriaMetrics
- Zabbix



7. 
 Запустил стек TICK командой ./sandbox up
Выключил контейнеры telegraf, chronograf, kapacitor. Один контейнер influxdb оставил включёным, зашёл внутрь контейнера, создал user, password.
В конфигурационных файлах telegraf, chronograf, kapacitor настроил user и password. Затем включил эти три контейнера.
- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20145508.png)

8. 

- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20150123.png)
- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20153326.png)
- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20153419.png)

9. 
- Изменил секцию telegraf в docker-compose.yml:

  telegraf:
    build:
      context: ./images/telegraf/
      dockerfile: ./${TYPE}/Dockerfile
      args:
        TELEGRAF_TAG: ${TELEGRAF_TAG}
    image: "telegraf"
    privileged: true
    environment:
      HOSTNAME: "telegraf-getting-started"
    links:
      - influxdb
    ports:
      - "8092:8092/udp"
      - "8094:8094"
      - "8125:8125/udp"
    volumes:
      - ./telegraf/telegraf.conf:/etc/telegraf/telegraf.conf:Z
      - /var/run/docker.sock:/var/run/docker.sock:Z
    depends_on:
      - influxdb 

- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20213050.png)
- ![scrin](https://github.com/Evgenii-379/10-monitoring-02-systems/blob/main/Снимок%20экрана%202025-02-11%20213226.png)


